# Code for the DR6 kSZ trispectrum measurement pipeline

This repository contains the pipeline code for generating the kSZ trispectrum measurements presented in [MacCrann et al. 2024](https://arxiv.org/abs/2405.01188).

The scripts in this repository use a library code which is confusingly called [ksz4](https://github.com/simonsobs/ksz4/tree/main), so start by installing that.

The rest of the complexity in the pipeline mainly comes down to pre-processing the DR6 data (in our case we use a harmonic-space ILC), and running bias corrections using simulations (which also need to be pre-processed/generated). 

# Generate ILC alms

- Run harmonic ILC on data k-space coadds, and noisy simulations (by combining ACT DR6 signal+noise sims and Planck noise sims). The noisy ACT simulations, generated by Frank, have the file format `kcoadd_v4_f${freq}_lmax7000_alm_set${set}_${seed}_split_${split}.fits`. These are CMB+noise only i.e. no foregrounds. Use the script `run_ilc.py` with arguments:
```
outdir="/pscratch/sd/m/maccrann/cmb/act_dr6/"
config="cldata_smooth-301-2_v4_lmax6000_60skmask_31102025"
srun -u -l -n 16  python run_ilc.py ${outdir}/ilc_${config} -c ilc_configs/${config}.yml
```
This generates ILC alms, and corresponding noisy simulations in the directory `/pscratch/sd/m/maccrann/cmb/act_dr6/ilc_cldata_smooth-301-2_v4_lmax6000_60skmask_31102025` in this case. 

As explained below however, we didn't actually use these exact simulations in the pipeline...

# Simulations 
We used a fairly confusing range of simulations for the DR6 paper in the end, definitely worth considering if we could simplify this.

1. For RDN0 and mean-field, we used noisy simulations with foreground power tuned to the data. In addition to the noisy simulations output by `run_ilc.py` above, we also Gaussian signal-only simulations with
power spectrum tuned to the data were run:
```
outdir="/pscratch/sd/m/maccrann/cmb/act_dr6/"
config="cldata_smooth-301-2_v4_lmax6000_60skmask_31102025"
srun -u -l -n 16 python sims/generate_gaussian_sims.py ${outdir}/ilc_${config}/gaussian_sims --data_template_path ${outdir}/ilc_${config}/\${freq}_split\${split}.fits --freqs hilc hilc-tsza
ndcibd hilc-tszd  --mpi --nsim 200 --mask_file ${outdir}/ilc_${config}/mask.fits --lmax 6000
```
This outputs Gaussian signal-only simulations. At the time, we had not saved noise-only simulations (only noise+CMB), so the script `sims/replace_signal.py` goes through subtracting the CMB signal, and replacing it with the Gaussian signal generated above. So we could simplify this a bit with access to the noise-only sims. Or write our own script to generate the sims. 
```
`srun -n 16 python replace_signal.py`
```
This outputs simulations in `/pscratch/sd/m/maccrann/cmb/act_dr6/ilc_cldata_smooth-301-2_v4_lmax6000_60skmask_31102025/data_signal_sims/`.
These are the simulations used for RDN0 and mean-field calculations. 

The plot below shows the improved signal-only agreement (as seen from the cross-based power spectrum) between data and sims ("tuned sim" means teh one with Gaussian signal matched to the data). 
![alt text](https://github.com/NiallMac/ksz2/blob/main/plots/include/cl_data_vs_sim.png)


2. We're not quite done yet unfortunately. For transfer function (aka MC bias) and covariance calculations, we used a different set of simulations where we add kSZ signal to the noisy simulations output by `run_ilc.py`. This kSZ signal is the Alvarez 2016 kSZ signal, randomly rotated for each simulation realisation. These are generated via the script `sim_e2e_test/add_ksz_signal_ilc.sh`.

# Running the pipeline

1. Run the measurement with bias corrections

2. Run the "end-to-end" simulations
`sim_e2e_test/run_e2e_sim.sh`
